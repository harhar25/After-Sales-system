const Gatepass = require('../models/Gatepass');
const ServiceOrder = require('../models/ServiceOrder');
const User = require('../models/User');

// Scan gatepass barcode and validate signatures
exports.scanGatepass = async (req, res) => {
  try {
    const { gatepassNumber } = req.body;
    
    if (!gatepassNumber) {
      return res.status(400).json({ message: 'Gatepass number is required' });
    }
    
    const gatepass = await Gatepass.findOne({ gatepassNumber })
      .populate('serviceOrderId')
      .populate('vehicleId')
      .populate('customerId')
      .populate('serviceAdvisorId')
      .populate('technicianId');
    
    if (!gatepass) {
      return res.status(404).json({ message: 'Gatepass not found' });
    }
    
    // Check if gatepass is expired
    if (gatepass.expiryDate && new Date() > gatepass.expiryDate) {
      return res.status(400).json({ 
        message: 'Gatepass has expired', 
        gatepass: gatepass 
      });
    }
    
    // Check if gatepass is valid
    if (!gatepass.isValid) {
      return res.status(400).json({ 
        message: 'Gatepass is invalid or cancelled', 
        gatepass: gatepass 
      });
    }
    
    // Validate all required signatures
    const signatureValidation = {
      isValid: gatepass.checkSignaturesValidation(),
      cashierSignature: gatepass.cashierSignature.isValidated,
      accountingSignature: gatepass.accountingSignature.isValidated,
      warrantySignature: gatepass.warrantySignature.isRequired ? gatepass.warrantySignature.isValidated : true,
      serviceManagerSignature: gatepass.serviceManagerSignature.isValidated
    };
    
    res.json({
      gatepass,
      signatureValidation,
      message: signatureValidation.isValid ? 'Gatepass is valid for vehicle release' : 'Missing required signatures'
    });
    
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Validate individual signature
exports.validateSignature = async (req, res) => {
  try {
    const { gatepassId } = req.params;
    const { signatureType } = req.body;
    const userId = req.user.id;
    
    const gatepass = await Gatepass.findById(gatepassId);
    if (!gatepass) {
      return res.status(404).json({ message: 'Gatepass not found' });
    }
    
    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    
    // Check if user has permission to validate this signature type
    const rolePermissions = {
      'cashier': ['Cashier'],
      'accounting': ['Accounting'],
      'warranty': ['Warranty Officer', 'Service Manager'],
      'serviceManager': ['Service Manager', 'Admin']
    };
    
    const allowedRoles = rolePermissions[signatureType];
    if (!allowedRoles || !allowedRoles.includes(user.role)) {
      return res.status(403).json({ 
        message: `User role '${user.role}' not authorized to validate ${signatureType} signature` 
      });
    }
    
    // Update signature validation
    switch (signatureType) {
      case 'cashier':
        gatepass.cashierSignature.isValidated = true;
        gatepass.cashierSignature.validatedBy = userId;
        gatepass.cashierSignature.validatedAt = new Date();
        break;
      case 'accounting':
        gatepass.accountingSignature.isValidated = true;
        gatepass.accountingSignature.validatedBy = userId;
        gatepass.accountingSignature.validatedAt = new Date();
        break;
      case 'warranty':
        if (!gatepass.warrantySignature.isRequired) {
          return res.status(400).json({ message: 'Warranty signature not required for this gatepass' });
        }
        gatepass.warrantySignature.isValidated = true;
        gatepass.warrantySignature.validatedBy = userId;
        gatepass.warrantySignature.validatedAt = new Date();
        break;
      case 'serviceManager':
        gatepass.serviceManagerSignature.isValidated = true;
        gatepass.serviceManagerSignature.validatedBy = userId;
        gatepass.serviceManagerSignature.validatedAt = new Date();
        break;
      default:
        return res.status(400).json({ message: 'Invalid signature type' });
    }
    
    // Update document status if all signatures are validated
    if (gatepass.checkSignaturesValidation()) {
      gatepass.documentStatus = 'Signed';
    }
    
    gatepass.lastModifiedBy = userId;
    await gatepass.save();
    
    res.json({
      message: `${signatureType} signature validated successfully`,
      gatepass,
      signatureValidation: {
        isValid: gatepass.checkSignaturesValidation(),
        cashierSignature: gatepass.cashierSignature.isValidated,
        accountingSignature: gatepass.accountingSignature.isValidated,
        warrantySignature: gatepass.warrantySignature.isRequired ? gatepass.warrantySignature.isValidated : true,
        serviceManagerSignature: gatepass.serviceManagerSignature.isValidated
      }
    });
    
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Release vehicle after all signatures are validated
exports.releaseVehicle = async (req, res) => {
  try {
    const { gatepassId } = req.params;
    const userId = req.user.id;
    
    const gatepass = await Gatepass.findById(gatepassId)
      .populate('serviceOrderId')
      .populate('vehicleId')
      .populate('customerId');
    
    if (!gatepass) {
      return res.status(404).json({ message: 'Gatepass not found' });
    }
    
    // Check if all required signatures are validated
    if (!gatepass.checkSignaturesValidation()) {
      return res.status(400).json({ 
        message: 'Cannot release vehicle - missing required signatures',
        signatureValidation: {
          isValid: gatepass.checkSignaturesValidation(),
          cashierSignature: gatepass.cashierSignature.isValidated,
          accountingSignature: gatepass.accountingSignature.isValidated,
          warrantySignature: gatepass.warrantySignature.isRequired ? gatepass.warrantySignature.isValidated : true,
          serviceManagerSignature: gatepass.serviceManagerSignature.isValidated
        }
      });
    }
    
    // Log vehicle release
    gatepass.logVehicleRelease(userId);
    await gatepass.save();
    
    // Update service order status if needed
    if (gatepass.serviceOrderId) {
      await ServiceOrder.findByIdAndUpdate(gatepass.serviceOrderId, {
        status: 'Completed',
        completedAt: new Date(),
        gatepassReleased: true
      });
    }
    
    res.json({
      message: 'Vehicle released successfully',
      gatepass,
      releaseInfo: {
        releasedAt: gatepass.vehicleReleasedAt,
        releasedBy: gatepass.vehicleReleasedBy,
        documentStatus: gatepass.documentStatus
      }
    });
    
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Get gatepass validation status
exports.getGatepassValidationStatus = async (req, res) => {
  try {
    const { gatepassId } = req.params;
    
    const gatepass = await Gatepass.findById(gatepassId)
      .populate('serviceOrderId')
      .populate('vehicleId')
      .populate('customerId');
    
    if (!gatepass) {
      return res.status(404).json({ message: 'Gatepass not found' });
    }
    
    const signatureValidation = {
      isValid: gatepass.checkSignaturesValidation(),
      cashierSignature: {
        present: !!gatepass.cashierSignature.cashierId,
        validated: gatepass.cashierSignature.isValidated,
        required: gatepass.cashierSignature.isRequired,
        signedAt: gatepass.cashierSignature.signedAt,
        validatedAt: gatepass.cashierSignature.validatedAt
      },
      accountingSignature: {
        present: !!gatepass.accountingSignature.accountantId,
        validated: gatepass.accountingSignature.isValidated,
        required: gatepass.accountingSignature.isRequired,
        signedAt: gatepass.accountingSignature.signedAt,
        validatedAt: gatepass.accountingSignature.validatedAt
      },
      warrantySignature: {
        present: !!gatepass.warrantySignature.warrantyOfficerId,
        validated: gatepass.warrantySignature.isValidated,
        required: gatepass.warrantySignature.isRequired,
        signedAt: gatepass.warrantySignature.signedAt,
        validatedAt: gatepass.warrantySignature.validatedAt
      },
      serviceManagerSignature: {
        present: !!gatepass.serviceManagerSignature.managerId,
        validated: gatepass.serviceManagerSignature.isValidated,
        required: gatepass.serviceManagerSignature.isRequired,
        signedAt: gatepass.serviceManagerSignature.signedAt,
        validatedAt: gatepass.serviceManagerSignature.validatedAt
      }
    };
    
    res.json({
      gatepass,
      signatureValidation,
      vehicleReleased: gatepass.vehicleReleased,
      documentStatus: gatepass.documentStatus
    });
    
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Get pending gatepasses for validation
exports.getPendingGatepasses = async (req, res) => {
  try {
    const userRole = req.user.role;
    const userId = req.user.id;
    
    let query = {
      documentStatus: { $in: ['Pending Signature', 'Signed'] },
      isValid: true,
      expiryDate: { $gt: new Date() }
    };
    
    // Filter based on user role
    switch (userRole) {
      case 'Cashier':
        query['cashierSignature.isValidated'] = false;
        break;
      case 'Accounting':
        query['accountingSignature.isValidated'] = false;
        break;
      case 'Warranty Officer':
        query['warrantySignature.isRequired'] = true;
        query['warrantySignature.isValidated'] = false;
        break;
      case 'Service Manager':
        query['serviceManagerSignature.isValidated'] = false;
        break;
      case 'Security':
        query['vehicleReleased'] = false;
        break;
      default:
        return res.status(403).json({ message: 'Access denied' });
    }
    
    const gatepasses = await Gatepass.find(query)
      .populate('serviceOrderId')
      .populate('vehicleId')
      .populate('customerId')
      .populate('serviceAdvisorId')
      .sort({ createdAt: -1 });
    
    res.json({
      gatepasses,
      count: gatepasses.length,
      userRole
    });
    
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};